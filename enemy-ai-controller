import {THREE} from './three-defs.js';

import {entity} from './entity.js';
import {math} from './math.js';

import {fsm} from './fsm.js';
import {globals} from './globals.js';


export const enemy_ai_controller = (() => {
  
  const _TMP_V3_0 = new THREE.Vector3();

  const _WANDER_FORCE = 0.5;
  const _MAX_TARGET_DISTANCE = 15;

  const _TMP_M0 = new THREE.Matrix4();
  const _TMP_Q0 = new THREE.Quaternion();

  class EnemyAIController extends entity.Component {
    constructor(params) {
      super();
      this.params_ = params;
      this.grid_ = params.grid;
      this.input_ = {axis1Forward:0, axis1Side:0};
      this.dead_ = false;
      this._mixer;
      this.scale = globals.scale
      this._animations = {};
      this._enemyStrikeFSM = new fsm.enemyStrikeFSM(this);
      this._enemyStrafeFSM = new fsm.enemyStrafeFSM(this);
    }

    InitComponent() {
      this.RegisterHandler_('physics.collision', (m) => { this.OnCollision_(m); });
      this.RegisterHandler_('health.dead', (m) => { this.OnDeath_(m); });
    }


    // 
    OnCollision_(){

    }

    OnDeath_(){
      if (!this.dead_) {
        this.dead_ = true;
      }
      
      this._enemyStrikeFSM.SetState('DeathIdle')
      this._enemyStrafeFSM.SetState('DeathIdle') 
    }

    Update(timeElapsed) {
    }

    Strike_() {
    }
  
    ApplyCollisionAvoidance_() {
      // should be online
      // back up 
    }
  
    ApplyWander_() {
    }

    ApplySeek_(destroyer) {
    }

    AcquireTarget_() {
    }

    ApplyAttack_() {
    }

    Update(timeInSeconds) {
      if (this.dead_) {
        return;
      }

      const input =  {axis1Forward:0, axis1Side:0};
      
      // this.Parent.Attributes.InputCurrent;
      if (!input) {
        return;
      }
      this._enemyStrikeFSM.Update(timeInSeconds, input);
      this._enemyStrafeFSM.Update(timeInSeconds, input);
      
      if(this._mixer){
        this._mixer.update(timeInSeconds);
      }
    }
  };

  return {
    EnemyAIController: EnemyAIController,
  };

})();
